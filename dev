#!/usr/bin/env bash
set -euo pipefail

CMD="${1:-help}"

# You can override these when running (e.g., API_URL=http://localhost:8080/api ./dev addbook ...)
API_URL="${API_URL:-http://localhost/api}"
WEB_URL="${WEB_URL:-http://localhost}"

pretty() {
  if command -v jq >/dev/null 2>&1; then jq .
  elif command -v python3 >/dev/null 2>&1; then python3 -m json.tool
  elif command -v python  >/dev/null 2>&1; then python  -m json.tool
  else cat; fi
}

is_wsl() { grep -qi microsoft /proc/version 2>/dev/null; }
is_msys() {
  case "${MSYSTEM:-$(uname -s)}" in
    MINGW*|MSYS*|CYGWIN*) return 0;;
    *) return 1;;
  esac
}

wait_http() {
  local url="$1"; local tries="${2:-60}"
  for _ in $(seq 1 "$tries"); do
    if curl -fsS "$url" -o /dev/null >/dev/null 2>&1; then return 0; fi
    sleep 1
  done
  return 1
}

open_browser() {
  echo "[INFO] Opening $WEB_URL ..."
  if is_msys; then
    command -v powershell.exe >/dev/null 2>&1 && { powershell.exe -NoLogo -NoProfile -Command "Start-Process '$WEB_URL'" >/dev/null 2>&1 & return 0; }
    command -v cmd.exe       >/dev/null 2>&1 && { cmd.exe /C start "" "$WEB_URL" >/dev/null 2>&1 & return 0; }
  fi
  if is_wsl; then
    command -v wslview       >/dev/null 2>&1 && { wslview "$WEB_URL" >/dev/null 2>&1 & return 0; }
    command -v powershell.exe>/dev/null 2>&1 && { powershell.exe -NoLogo -NoProfile -Command "Start-Process '$WEB_URL'" >/dev/null 2>&1 & return 0; }
  fi
  command -v xdg-open >/dev/null 2>&1 && { xdg-open "$WEB_URL" >/dev/null 2>&1 & return 0; }
  command -v open     >/dev/null 2>&1 && { open "$WEB_URL"      >/dev/null 2>&1 & return 0; }
  echo "[WARN] Could not auto-open. Please open: $WEB_URL"
}

case "$CMD" in
  up)
    docker compose up -d --build
    wait_http "$API_URL/health" 60 || echo "[WARN] API not reachable yet: $API_URL/health"
    open_browser
    ;;

  restart)
    docker compose down
    docker compose up -d --build
    wait_http "$API_URL/health" 60 || echo "[WARN] API not reachable yet: $API_URL/health"
    open_browser
    ;;

  build)
    docker compose build
    ;;

  down)
    docker compose down
    ;;

  clean|prune)
    docker compose down -v
    ;;

  logs)
    docker compose logs -f
    ;;

  ps)
    docker compose ps
    ;;

  health)
    curl -s "$API_URL/health" | pretty
    ;;

  search)
    # ./dev search "kinase receptor phosphorylation" [top_k]
    q="${2:-kinase receptor phosphorylation}"
    k="${3:-3}"
    curl -s "$API_URL/search" \
      -H 'content-type: application/json' \
      -d "{\"query\":\"$q\",\"top_k\":$k}" | pretty
    ;;

  add-chunk)
    # ./dev add-chunk "Book Title" "Section" 0 "Your textâ€¦"
    bt="${2:-Kinase Handbook}"
    sec="${3:-Intro}"
    idx="${4:-0}"
    body="${5:-Receptor tyrosine kinases (RTKs) are...}"
    curl -s "$API_URL/chunks/auto" \
      -H 'content-type: application/json' \
      -d "{\"book_title\":\"$bt\",\"section\":\"$sec\",\"chunk_idx\":$idx,\"body\":\"$body\"}" | pretty
    ;;

  web-build)
    # Rebuild the Vite app via the frontend builder service
    docker compose run --rm frontend
    docker compose restart nginx || true
    ;;

  open)
    open_browser
    ;;

  addbook)
    # Usage:
    #   ./dev addbook path/to/text.txt ["Book Title"] ["Section"] [chunk_chars] [overlap_chars]
    #
    # Defaults:
    #   title        = filename (no extension)
    #   section      = "Full Text"
    #   chunk_chars  = 1200
    #   overlap      = 150
    infile="${2:-}"
    [ -z "${infile}" ] && { echo "[ERROR] Provide a text file"; exit 1; }
    [ ! -f "${infile}" ] && { echo "[ERROR] File not found: ${infile}"; exit 1; }

    title="${3:-$(basename "$infile" | sed 's/\.[^.]*$//')}"
    section="${4:-Full Text}"
    chunk_chars="${5:-1200}"
    overlap_chars="${6:-150}"

    echo "[INFO] Reading: $infile"
    echo "[INFO] Title:   $title"
    echo "[INFO] Section: $section"
    echo "[INFO] Chunk ~${chunk_chars} chars with ${overlap_chars} overlap"
    echo "[INFO] Posting to $API_URL/chunks/auto"

    # Ensure Python writes UTF-8 on Windows consoles; also JSON-escape non-ASCII.
    PYTHONIOENCODING=UTF-8 \
    BOOK_TITLE="$title" SECTION="$section" CHUNK_CHARS="$chunk_chars" OVERLAP="$overlap_chars" \
    python3 - "$infile" <<'PY' | while IFS= read -r json; do
import os, sys, re, json

path       = sys.argv[1]
book_title = os.environ.get("BOOK_TITLE", "Untitled")
section    = os.environ.get("SECTION", "Full Text")
chunk_len  = int(os.environ.get("CHUNK_CHARS", "1200"))
overlap    = int(os.environ.get("OVERLAP", "150"))

with open(path, "r", encoding="utf-8", errors="ignore") as f:
    raw = f.read()

# Normalize whitespace
raw = re.sub(r'\r\n?', '\n', raw)
raw = re.sub(r'[ \t]+', ' ', raw)
raw = re.sub(r'\n{3,}', '\n\n', raw).strip()

# Keep paragraphs; split into sentence-like units
paras = [p.strip() for p in raw.split("\n\n") if p.strip()]
units = []
for p in paras:
    if re.match(r'^(#+\s|[A-Z][A-Z0-9 _-]{2,}$)', p):  # headings
        units.append(p)
        continue
    parts = re.split(r'(?<=[.!?])\s+(?=[A-Z(0-9"])', p)
    for s in parts:
        s = s.strip()
        if s:
            units.append(s)

chunks, buf = [], ""
for u in units:
    add = u if not buf else (buf + " " + u)
    if len(add) <= chunk_len:
        buf = add
    else:
        if buf:
            chunks.append(buf.strip())
        if overlap > 0 and chunks:
            tail = chunks[-1][-overlap:]
            buf = (tail + " " + u).strip()
        else:
            buf = u
if buf:
    chunks.append(buf.strip())

for i, body in enumerate(chunks):
    # ensure_ascii=True avoids Windows CP1252 stdout errors
    print(json.dumps({
        "book_title": book_title,
        "section": section,
        "chunk_idx": i,
        "body": body
    }, ensure_ascii=True))
PY
      # Post each JSON line; accept 200 or 201
      http_code=$(curl -s -o /tmp/.addbook_resp.$$ -w "%{http_code}" \
        "$API_URL/chunks/auto" \
        -H 'content-type: application/json; charset=utf-8' \
        --data-binary "$json")
      if [ "$http_code" = "200" ] || [ "$http_code" = "201" ]; then
        echo "[OK] chunk posted"
      else
        echo "[ERR] HTTP $http_code"
        cat /tmp/.addbook_resp.$$
        echo
        rm -f /tmp/.addbook_resp.$$
        exit 1
      fi
      rm -f /tmp/.addbook_resp.$$
    done
    echo "[DONE] All chunks inserted."
    ;;

  help|*)
    cat <<'USAGE'
Usage: ./dev <command>

Core:
  up                Build & start services, wait for API, open browser
  restart           Rebuild & restart, wait for API, open browser
  build             Build images only
  down              Stop and remove containers
  clean             Stop containers & remove volumes (DB data!)
  logs              Follow logs
  ps                Show service status

API shortcuts:
  health            GET /api/health
  search [q] [k]    POST /api/search (default q="kinase receptor phosphorylation", k=3)
  add-chunk [title] [section] [idx] [body]   POST /api/chunks/auto

Frontend:
  web-build         Rebuild the Vite app via the frontend builder service
  open              Open the site in your browser

RAG:
  addbook path/to/text.txt ["Book Title"] ["Section"] [chunk_chars] [overlap_chars]
    - Default title = filename without extension
    - Default section = "Full Text"
    - Default chunk_chars = 1200
    - Default overlap = 150

Env overrides:
  API_URL (default http://localhost/api)
  WEB_URL (default http://localhost)
USAGE
    ;;
esac
